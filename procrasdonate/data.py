from django.db import models
from lib import model_utils

import re

class Email(models.Model):
    """
    """
    email = models.EmailField(db_index=True)
    
    def send_email(self, message, subject, sender):
        pass
    
    @classmethod
    def get_or_create(klass, email):
        e = Email.get_or_none(email=email)
        if e:
            return e
        else:
            return Email.add(email)
    
    @classmethod
    def make(klass, email):
        return Email(email=email)
        
    def __unicode__(self):
        return u"%s" % self.email

class User(models.Model):
    """
    Extension users may optionally provide us with their email address and other information
    for say an announcements list.
    The hashed field, which is the only required field, is a user id generated by the extension.
    """
    hash = models.CharField(max_length=10, db_index=True)
    # currently defaults to twitter_username, but one day twitter_username may not be king.
    # that day is now.
    name = models.CharField(max_length=128, blank=True, null=True)
    twitter_name = models.CharField(max_length=32, blank=True, null=True)
    url = models.URLField(blank=True, null=True)
    email = models.ForeignKey(Email, blank=True, null=True)
    on_email_list = models.BooleanField(default=False)
    
    @classmethod
    def get_or_create(klass, hash):
        u = User.get_or_none(hash=hash)
        if not u:
            u = User.add(hash)
        return u
    
    @classmethod
    def make(klass, hash, name=None, twitter_name=None, url=None, email=None, on_email_list=False):
        """
        @param email: string email
        """
        email = email and Email.get_or_create(email) or None
        return User(hash=hash,
                    name=name,
                    twitter_name=twitter_name,
                    url=url,
                    email=email,
                    on_email_list=on_email_list)
        
    def __unicode__(self):
        return u"%s - %s - %s - %s - %s - %s" % (self.hash,
                                                 self.name,
                                                 self.twitter_name,
                                                 self.url,
                                                 self.email,
                                                 self.on_email_list)

class Site(models.Model):
    """
    Content provider.
    This is not a website that someone simple visited, 
    but rather a content provider that someone paid to visit.
    """
    url = models.URLField()
    sitegroup = models.ForeignKey('SiteGroup')
    
    @classmethod
    def get_or_create(klass, url):
        s = Site.get_or_none(url=url)
        if not s:
            host = SiteGroup.extract_host(url)
            s = Site.add(url,
                         SiteGroup.get_or_create(host=host))
        return s

    @classmethod
    def make(klass, url, sitegroup):
        return Site(url=url, sitegroup=sitegroup)
    
    def __unicode__(self):
        return u"%s (%s)" % (self.url, self.sitegroup)

class SiteGroup(models.Model):
    """
    Domain-based group of Sites
    """
    host = models.CharField(max_length=128)
    # describes valid urls
    url_re = models.CharField(max_length=128, null=True, blank=True)
    name = models.CharField(max_length=128, null=True, blank=True)
    
    HOST_RE = re.compile("http://([^/]+)")
    
    @classmethod
    def extract_host(klass, url):
        match = SiteGroup.HOST_RE.match(url)
        if match:
            return match.groups()[0]
        return url
    
    @classmethod
    def get_or_create(klass, host, url_re=None, name=None):
        s = SiteGroup.get_or_none(host=host)
        if not s:
            s = SiteGroup.add(host)
        return s
    
    @classmethod
    def make(klass, host, url_re=None, name=None):
        return SiteGroup(host=host,
                         url_re=url_re,
                         name=name)
    
    def __unicode__(self):
        return u"%s" % self.host

class Recipient(models.Model):
    """
    Recipient of donations
    """
    name = models.CharField(max_length=128)
    slug = models.CharField(max_length=128)
    email = models.EmailField()
    url = models.URLField(null=True, blank=True)
    twitter_name = models.CharField(max_length=32, null=True, blank=True)
    mission = models.CharField(max_length=256, null=True, blank=True)
    description = models.TextField(null=True, blank=True)
    is_visible = models.BooleanField(default=False)
    category = models.ForeignKey('Category', blank=True, null=True)
    
    @classmethod
    def make(klass,
             name,
             slug,
             email=None,
             url=None,
             twitter_name=None,
             mission=None,
             description=None,
             is_visible=True,
             category=None):
        if category:
            category = Category.get_or_create(category)
        return Recipient(name=name,
                         slug=model_utils.slugify(name),
                         twitter_name=twitter_name,
                         url=url,
                         email=email,
                         mission=mission,
                         description=description,
                         is_visible=is_visible, 
                         category=category)
        
        
    def deep_dict(self):
        return {'name': self.name,
                'slug': self.slug,
                'email': self.email,
                'url': self.url,
                'twitter_name': self.twitter_name,
                'mission': self.mission,
                'description': self.description,
                'is_visible': self.is_visible,
                'category': self.category.category}
        
    def __unicode__(self):
        return u"%s - %s - %s - %s" % (self.twitter_name,
                                       self.name,
                                       self.category,
                                       self.is_visible)

class Tag(models.Model):
    """
    """
    tag = models.CharField(max_length=64)
    
    @classmethod
    def get_or_create(klass, tag):
        t = Tag.get_or_none(tag=tag)
        if t:
            return t
        else:
            return Tag.add(tag)
    
    @classmethod
    def make(klass, tag):
        return Tag(tag=tag)
    
    def __unicode__(self):
        return u"%s" % self.tag

class Category(models.Model):
    """
    """
    category = models.CharField(max_length=200)
    
    @classmethod
    def get_or_create(klass, category):
        t = Category.get_or_none(category=category)
        if t:
            return t
        else:
            return Category.add(category)
    
    @classmethod
    def make(klass, category):
        return Category(category=category)
    
    def __unicode__(self):
        return self.category
    
    def __unicode__(self):
        return u"%s" % self.category

class Visit(models.Model):
    """
    payment or pledge or something from a single user.
    If donated some money to some recipient for time spent on some site,
    then we expect two Visits to be created: one for the site
    and one for the recipient (and possibly a second recipient if some 
    percent is also going to @ProcrasDonate). These two Visits
    will doubly account for the time_spent and amount [donated]. 
    The time_spent and amount [donated] across all sites and recipients
    with the same incoming_tipjoy_transaction_id should cancel out.
    """
    # datetime of tipjoy payment
    datetime = models.DateField()
    # time spent procrastinating in seconds. likely max is 24 (hr) * 60 (min) * 60 (s)
    total_time = models.FloatField()
    # amount donated in cents
    total_amount = models.FloatField()
    # rate of payment in cents per hour 
    # GENERATED based on total_time and total_amount
    # WARNING: this is the rate at the time of payment. 
    # the rate could have changed halfway through the day,
    # so do not expect a meaningful relationship between rate and totals
    rate = models.FloatField(default=0)

    user = models.ForeignKey(User, null=True, blank=True)
    # id of item in extension database
    extn_id = models.IntegerField()
    
    class Meta:
        abstract = True
        ordering = ('datetime',)
    
    def __unicode__(self):
        return u"%s :%s: - %s - %s cents" % (self.datetime,
                                             self.user.hash,
                                             self.total_time,
                                             self.total_amount)
    @classmethod
    def make(klass, datetime, total_time, total_amount, user, extn_id, extn_inst, extn_inst_name, the_klass):
        """
        @param extn_id: 
        @param extn_inst: 
        @param extn_inst_name: 
        @param the_klass: 
        """
        # total_amount / total_time
        rate = (total_amount * 3600) / total_time;
        the_inst = the_klass(datetime=datetime,
                             total_time=total_time,
                             total_amount=total_amount,
                             rate=rate,
                             user=user,
                             extn_id=extn_id)
        setattr(the_inst, extn_inst_name, extn_inst)
        return the_inst
        
class SiteGroupVisit(Visit):
    """
    """
    sitegroup = models.ForeignKey(SiteGroup)
    
    @classmethod
    def make(klass, sitegroup, datetime, total_time, total_amount, user, extn_id):
       return Visit.make(datetime,
                         total_time,
                         total_amount,
                         user,
                         extn_id,
                         sitegroup,
                         "sitegroup",
                         SiteGroupVisit)
    
    def __unicode__(self):
        return "%s [[%s]]" % (self.sitegroup, super(SiteGroupVisit, self).__unicode__())

class SiteVisit(Visit):
    """
    """
    site = models.ForeignKey(Site)
    
    @classmethod
    def make(klass, site, datetime, total_time, total_amount, user, extn_id):
       return Visit.make(datetime,
                         total_time,
                         total_amount,
                         user,
                         extn_id,
                         site,
                         "site",
                         SiteVisit)
    
    def __unicode__(self):
        return "%s [[%s]]" % (self.site, super(SiteVisit, self).__unicode__())

class RecipientVisit(Visit):
    """
    """
    recipient = models.ForeignKey(Recipient)
    
    @classmethod
    def make(klass, recipient, datetime, total_time, total_amount, user, extn_id):
       return Visit.make(datetime,
                         total_time,
                         total_amount,
                         user,
                         extn_id,
                         recipient,
                         "recipient",
                         RecipientVisit)
    
    def __unicode__(self):
        return "%s [[%s]]" % (self.recipient, super(RecipientVisit, self).__unicode__())

class TagVisit(Visit):
    """
    """
    tag = models.ForeignKey(Tag)
    
    @classmethod
    def make(klass, tag, datetime, total_time, total_amount, user, extn_id):
       return Visit.make(datetime,
                         total_time,
                         total_amount,
                         user,
                         extn_id,
                         tag,
                         "tag",
                         TagVisit)
       
    def __unicode__(self):
        return "%s [[%s]]" % (self.tag, super(TagVisit, self).__unicode__())

class PaymentService(models.Model):
    name = models.CharField(max_length=200)
    user_url = models.URLField()
    
    @classmethod
    def make(klass, name, user_url):
        return PaymentService(name=name, user_url=user_url)
    
    def __unicode__(self):
        return self.name

class Payment(models.Model):
    datetime = models.DateTimeField(db_index=True)
    payment_service = models.ForeignKey(PaymentService)
    transaction_id = models.CharField(max_length=32, db_index=True)
    settled = models.BooleanField(default=False)
    total_amount_paid = models.FloatField(default=0.0)
    amount_paid_in_fees = models.FloatField(default=0.0)
    amount_paid_tax_deductibly = models.FloatField(default=0.0)
    user = models.ForeignKey(User)
    extn_id = models.IntegerField()

    class Meta:
        abstract = True

    @classmethod
    def make(klass,
             datetime,
             payment_service,
             transaction_id,
             settled,
             total_amount_paid,
             amount_paid_in_fees,
             amount_paid_tax_deductibly,
             user,
             extn_id,
             extn_inst,
             extn_inst_name,
             the_klass):
        
        """
        @param extn_id: 
        @param extn_inst: 
        @param extn_inst_name: 
        @param the_klass:
        """
        the_inst = the_klass(datetime=datetime,
                             payment_service=payment_service,
                             transaction_id=transaction_id,
                             settled=settled,
                             total_amount_paid=total_amount_paid,
                             amount_paid_in_fees=amount_paid_in_fees,
                             amount_paid_tax_deductibly=amount_paid_tax_deductibly,
                             user=user,
                             extn_id=extn_id)
        setattr(the_inst, extn_inst_name, extn_inst)
        return the_inst
    
    def __unicode__(self):
        return self.name
    
class RecipientPayment(Payment):
    recipient = models.ForeignKey(Recipient)
    
    @classmethod
    def make(klass,
             recipient,
             datetime,
             payment_service,
             transaction_id,
             settled,
             total_amount_paid,
             amount_paid_in_fees,
             amount_paid_tax_deductibly,
             user,
             extn_id,
             extn_inst,
             extn_inst_name,
             the_klass):

        return Payment.make(datetime,
                            payment_service,
                            transaction_id,
                            settled,
                            total_amount_paid,
                            amount_paid_in_fees,
                            amount_paid_tax_deductibly,
                            user,
                            extn_id,
                            recipient,
                            "recipient",
                            RecipientPayment)

class SitePayment(Payment):
    site = models.ForeignKey(Site)
    
    @classmethod
    def make(klass,
             site,
             datetime,
             payment_service,
             transaction_id,
             settled,
             total_amount_paid,
             amount_paid_in_fees,
             amount_paid_tax_deductibly,
             user,
             extn_id,
             extn_inst,
             extn_inst_name,
             the_klass):

        return Payment.make(datetime,
                            payment_service,
                            transaction_id,
                            settled,
                            total_amount_paid,
                            amount_paid_in_fees,
                            amount_paid_tax_deductibly,
                            user,
                            extn_id,
                            site,
                            "site",
                            SitePayment)

ALL_MODELS = [Email,
              User,
              Site,
              SiteGroup,
              Tag,
              Category,
              Recipient,
              SiteVisit,
              SiteGroupVisit,
              RecipientVisit,
              TagVisit,
              PaymentService,
              SitePayment,
              RecipientPayment
              ]
